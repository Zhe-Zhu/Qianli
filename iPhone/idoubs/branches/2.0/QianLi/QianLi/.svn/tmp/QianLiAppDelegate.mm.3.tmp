//
//  QianLiAppDelegate.m
//  QianLi
//
//  Created by Chen Xiangwen on 5/8/13.
//  Copyright (c) 2013 Chen Xiangwen. All rights reserved.
//

#import "QianLiAppDelegate.h"
#import "QianLiContactsViewController.h"
#import "HistoryRecordsMainViewController.h"
#import "SipStackUtils.h"
#import "iOSNgnStack.h"
#import "MediaSessionMgr.h"
#import "SettingViewController.h"
#import "SignUpEditProfileViewController.h"
#import "MainHistoryDataAccessor.h"
#import "HelpViewController.h"
#import "QianLiContactsAccessor.h"
#import "HistoryTransUtils.h"
#import "MobClick.h"
#import "UMFeedback.h"

@interface QianLiAppDelegate (){
    UITabBarController *_tabController;
    SignUpEditProfileViewController *_signUpEditProfileViewController;
    BOOL multitaskingSupported;
}

@property(nonatomic, strong) SignUpEditProfileViewController *signUpEditProfileViewController;
@property(nonatomic, weak)QianLiContactsViewController *contactViewController;
@property(nonatomic, weak)HistoryRecordsMainViewController *historyMainController;
@property(nonatomic, weak)SettingViewController *settingViewController;
@property(nonatomic, weak)QianLiAudioCallViewController *audioCallViewController;

@end

@implementation QianLiAppDelegate

@synthesize managedObjectContext = _managedObjectContext;
@synthesize managedObjectModel = _managedObjectModel;
@synthesize persistentStoreCoordinator = _persistentStoreCoordinator;
@synthesize tabController = _tabController;

// 最近通话 联系人 设置界面的Navigation Bar颜色
const float kColorH = 187/360.0;
const float kColorS = 70/100.0;
const float kColorB = 60/100.0;

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    _didJustLaunch = YES;
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    // Override point for customization after application launch.
    self.window.backgroundColor = [UIColor whiteColor];
    UITabBarController *tabController = [[UITabBarController alloc] init];
    _tabController = tabController;
    
    // load the storyboard by name
    UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"MainStoryboard" bundle:nil];
    
    // 设置TabBar
    _contactViewController = [storyboard instantiateViewControllerWithIdentifier:@"ContactViewController"];
    _contactViewController.title = @"联系人";
    UINavigationControllerPortraitViewController *contactNavigationVC = [[UINavigationControllerPortraitViewController alloc] init];
    // 配置navigation controller
    [contactNavigationVC.navigationBar setTranslucent:NO];
    [contactNavigationVC.navigationBar setBarTintColor:[UIColor colorWithHue:kColorH saturation:kColorS brightness:kColorB alpha:1.0]];
    [contactNavigationVC.navigationBar setBarStyle:UIBarStyleBlack];
    contactNavigationVC.viewControllers = @[_contactViewController];
    // 加入Tab Bar上的Icon
    UITabBarItem *contactIcon = [[UITabBarItem alloc] initWithTitle:@"联系人" image:[UIImage imageNamed:@"contactIcon.png"] selectedImage:[UIImage imageNamed:@"contactIconSelected.png"]];
    contactNavigationVC.tabBarItem = contactIcon;
    
    _historyMainController = [storyboard instantiateViewControllerWithIdentifier:@"HistroryRecordMainController"];
    _historyMainController.title = @"最近通话";
    UINavigationControllerPortraitViewController *histroyNaviCV = [[UINavigationControllerPortraitViewController alloc] init];
    // 配置navigation controller
    [histroyNaviCV.navigationBar setTranslucent:NO];
    [histroyNaviCV.navigationBar setBarTintColor:[UIColor colorWithHue:kColorH saturation:kColorS brightness:kColorB alpha:1.0]];
    [histroyNaviCV.navigationBar setBarStyle:UIBarStyleBlack];
    UIImageView *lineView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 44, 320, 2)];
    lineView.backgroundColor = [UIColor colorWithRed:160/255.0 green:160/255.0 blue:160/255.0 alpha:0.3];
    [histroyNaviCV.navigationBar addSubview:lineView];
    histroyNaviCV.viewControllers = @[_historyMainController];
    // 加入Tab Bar上的Icon
    UITabBarItem *historyIcon = [[UITabBarItem alloc] initWithTitle:@"最近通话" image:[UIImage imageNamed:@"historyIcon.png"] selectedImage:[UIImage imageNamed:@"historyIconSelected.png"]];
    histroyNaviCV.tabBarItem = historyIcon;
    
    // 读取storyboard中的setting view
    _settingViewController = [storyboard instantiateViewControllerWithIdentifier:@"SettingViewController"];
    UINavigationControllerPortraitViewController *settingNavigationController = [[UINavigationControllerPortraitViewController alloc] init];
    // 配置navigation controller
    [settingNavigationController.navigationBar setTranslucent:NO];
    [settingNavigationController.navigationBar setBarTintColor:[UIColor colorWithHue:kColorH saturation:kColorS brightness:kColorB alpha:1.0]];
    [settingNavigationController.navigationBar setBarStyle:UIBarStyleBlack];
    settingNavigationController.viewControllers = @[_settingViewController];
    settingNavigationController.title = @"设置";
    // 加入Tab Bar上的Icon
    UITabBarItem *settingIcon = [[UITabBarItem alloc] initWithTitle:@"设置" image:[UIImage imageNamed:@"settingIcon.png"] selectedImage:[UIImage imageNamed:@"settingIconSelected.png"]];
    settingNavigationController.tabBarItem = settingIcon;
    
    NSArray *controllers = @[histroyNaviCV, contactNavigationVC,settingNavigationController];
    _tabController.viewControllers = controllers;
    [_tabController.tabBar setTintColor:[UIColor colorWithRed:56/255.0 green:181/255.0 blue:199/255.0 alpha:1.0]];
    [_tabController.tabBar setTranslucent:YES];
    [self.window makeKeyAndVisible];
    
    // Register remote notification
    UIApplication *app = [UIApplication sharedApplication];
    [app registerForRemoteNotificationTypes: UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound];
    
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(recieveIncomingCallNotif:) name:kReceiveIncomingCallNotifName object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onStackEvent:) name:kNgnStackEventArgs_Name object:nil];
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    // TODO: For debug
    //[userDefaults setBool:YES forKey:@"SignedUp"];
//    [UserDataAccessor setUserRemoteParty:@"008618682120348"];
//    [UserDataAccessor setUserRemoteParty:@"008615977340900"];
    if ([userDefaults boolForKey:@"SignedUp"]) {
        self.window.rootViewController = _tabController;
        [[SipStackUtils sharedInstance] start];
        [self configureParmsWithNumber:[UserDataAccessor getUserRemoteParty]];
        [[SipStackUtils sharedInstance].soundService configureAudioSession];
        [[SipStackUtils sharedInstance].soundService configureSpeakerEnabled:YES];
        [[SipStackUtils sharedInstance] queryConfigurationAndRegister];
    }
    else{
        // TODO: 完成编辑profile界面的编写后将其删掉
        SignUpEditProfileViewController *signUpEditProfileViewController = [storyboard instantiateViewControllerWithIdentifier:@"RegisterNavigationController"];
        _signUpEditProfileViewController = signUpEditProfileViewController;
        self.window.rootViewController = signUpEditProfileViewController;
    }
    
//    NSDictionary *remoteNotification = [launchOptions valueForKey:UIApplicationLaunchOptionsRemoteNotificationKey];
//    if (remoteNotification) {
//        //
//    }
    
    
    // 初始化UmengSDK
    [MobClick startWithAppkey:kUmengSDKKey];
    [UMFeedback checkWithAppkey:kUmengSDKKey];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(umCheck:) name:UMFBCheckFinishedNotification object:nil];
    
    return YES;
}

- (void)resetRootViewController
{
    [UIView transitionFromView:_signUpEditProfileViewController.view toView:_tabController.view duration:0.5 options:UIViewAnimationOptionCurveEaseIn|UIViewAnimationOptionTransitionCrossDissolve completion:^(BOOL finished){
        self.window.rootViewController = _tabController;
    }];
    
    [[SipStackUtils sharedInstance] start];
    [self configureParmsWithNumber:[UserDataAccessor getUserRemoteParty]];
    [[SipStackUtils sharedInstance].soundService configureAudioSession];
    [[SipStackUtils sharedInstance].soundService configureSpeakerEnabled:YES];
    [[SipStackUtils sharedInstance] queryConfigurationAndRegister];
}

- (void)configureSip
{
    // Set media parameters if you want
	MediaSessionMgr::defaultsSetAudioGain(0, 0);
	// Set some codec priorities
}

- (void)applicationWillResignActive:(UIApplication *)application
{
    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
}

- (void)applicationDidEnterBackground:(UIApplication *)application
{
    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. 
    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
    
    [[SipStackUtils sharedInstance] queryConfigurationAndRegister];
    [application setKeepAliveTimeout:600 handler:^{
        [[SipStackUtils sharedInstance] queryConfigurationAndRegister];
    }];

    [_contactViewController clearContacts];
    [_historyMainController clearHistory];
    [_settingViewController clearImages];
}

- (void)applicationWillEnterForeground:(UIApplication *)application
{
    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
    [[HistoryTransUtils sharedInstance] getHistoryInBackground:NO];
    [application clearKeepAliveTimeout];
    switch (_tabController.selectedIndex) {
        case 0:
            [_historyMainController restoreHistory];
            break;
        case 1:
            [_contactViewController restoreContacts];
            break;
        case 2:
            [_settingViewController restoreImages];
            break;
        default:
            break;
    }
    
    ConnectionState_t registrationState = [[NgnEngine sharedInstance].sipService getRegistrationState];
    switch (registrationState) {
		case CONN_STATE_CONNECTING:
		case CONN_STATE_TERMINATING:
			[[SipStackUtils sharedInstance] unRegisterIdentity];
            [[SipStackUtils sharedInstance] queryConfigurationAndRegister];
			break;
        default:
            [[SipStackUtils sharedInstance] queryConfigurationAndRegister];
			break;
	}
    
    [self displayPushNotificationWarning];
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{
    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
    //NSInteger number = [UIApplication sharedApplication].applicationIconBadgeNumber;
    //[self setTabItemBadge:number];
    if (_tabController.selectedIndex == 0) {
        [UIApplication sharedApplication].applicationIconBadgeNumber = 0;
    }
    
    // Umeng
    [UMFeedback checkWithAppkey:kUmengSDKKey];
}

- (void)applicationWillTerminate:(UIApplication *)application
{
    // Saves changes in the application's managed object context before the application terminates.
    [self saveContext];
    [[SipStackUtils sharedInstance] stop];
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application
{
    [[NgnEngine sharedInstance].contactService unload];
	[[NgnEngine sharedInstance].historyService clear];
	[[NgnEngine sharedInstance].storageService clearFavorites];
}

- (void)saveContext
{
    NSError *error = nil;
    NSManagedObjectContext *managedObjectContext = self.managedObjectContext;
    if (managedObjectContext != nil) {
        if ([managedObjectContext hasChanges] && ![managedObjectContext save:&error]) {
             // Replace this implementation with code to handle the error appropriately.
             // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
            NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
            //abort();
        } 
    }
}

- (void)recieveIncomingCallNotif:(NSNotification *)userInfo
{
    NSDictionary * info = [userInfo userInfo];
    NSString *notifKey = (NSString *)[info objectForKey:kNotifKey];
    // handle a incoming call
	if([notifKey isEqualToString:kNotifKey_IncomingCall])
    {
        UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"MainStoryboard" bundle:nil];
        UINavigationController *audioCallNavigationController = [storyboard instantiateViewControllerWithIdentifier:@"audioCallNavigationController"];
        _audioCallViewController = (QianLiAudioCallViewController *)audioCallNavigationController.topViewController;
        _audioCallViewController.ViewState = ReceivingCall;
        
        NSNumber* sessionId = [info objectForKey:kNotifIncomingCall_SessionId];
        if ([[SipStackUtils sharedInstance].audioService hasSessionWithId:[sessionId longValue]]) {
            _audioCallViewController.audioSessionID = [sessionId longValue];
            [SipStackUtils sharedInstance].sessionID = [sessionId longValue];
            _audioCallViewController.remotePartyNumber = [[SipStackUtils sharedInstance] getRemotePartyNumber];
            
            NSString *imageSessionID = [NSString stringWithFormat:@"%@%@",[[SipStackUtils sharedInstance] getRemotePartyNumber], [UserDataAccessor getUserRemoteParty]];
            [[PictureManager sharedInstance] setImageSession:imageSessionID];
            
            NSString *name = [[QianLiContactsAccessor sharedInstance] getNameForRemoteParty:[[SipStackUtils sharedInstance] getRemotePartyNumber]];
            if (name) {
                [[MainHistoryDataAccessor sharedInstance] updateForRemoteParty:[[SipStackUtils sharedInstance] getRemotePartyNumber] Content:[NSString stringWithFormat:@"Received call from %@", name] Time:[[NSDate date] timeIntervalSince1970] Type:@"InComingCall"];
            }
            else{
                //go to server to get name;
                [[MainHistoryDataAccessor sharedInstance] updateForRemoteParty:[[SipStackUtils sharedInstance] getRemotePartyNumber] Content:[NSString stringWithFormat:@"Received call from %@", [[SipStackUtils sharedInstance] getRemotePartyNumber]] Time:[[NSDate date] timeIntervalSince1970] Type:@"InComingCall"];
            }
        }
        
        [self.tabController presentViewController:audioCallNavigationController animated:YES completion:nil];
        
        // Add to history record
        NgnHistoryAVCallEvent *event = [[NgnHistoryAVCallEvent alloc] init:NO withRemoteParty:[[SipStackUtils sharedInstance] getRemotePartyNumber]];
        event.status = HistoryEventStatus_Incoming;
        event.start = [[NSDate date] timeIntervalSince1970];
        _audioCallViewController.activeEvent = event;
        
        //play music
        if ([UIApplication sharedApplication].applicationState == UIApplicationStateActive) {
            [[SipStackUtils sharedInstance].soundService playRingTone];
        }
    }
}

- (void)configureParmsWithNumber:(NSString *)number
{
    [[NgnEngine sharedInstance].configurationService setStringWithKey:IDENTITY_DISPLAY_NAME andValue:number];
    [[NgnEngine sharedInstance].configurationService setStringWithKey:IDENTITY_IMPU andValue:[NSString stringWithFormat:@"sip:%@@112.124.36.134",number]];
    [[NgnEngine sharedInstance].configurationService setStringWithKey:IDENTITY_IMPI andValue:number];
    [[NgnEngine sharedInstance].configurationService setStringWithKey:IDENTITY_PASSWORD andValue:number];
    [[NgnEngine sharedInstance].configurationService setStringWithKey:NETWORK_REALM andValue:@"112.124.36.134"];
    [[NgnEngine sharedInstance].configurationService setBoolWithKey:NETWORK_USE_EARLY_IMS andValue:YES];
    [[NgnEngine sharedInstance].configurationService setStringWithKey:NETWORK_PCSCF_HOST andValue:@"112.124.36.134"];
   // [[NgnEngine sharedInstance].configurationService setBoolWithKey:NATT_USE_STUN_DISCO andValue:YES];
    [[NgnEngine sharedInstance].configurationService setBoolWithKey:NETWORK_USE_KEEPAWAKE andValue:YES];
    [[NgnEngine sharedInstance].configurationService setBoolWithKey:NETWORK_USE_3G andValue:YES];
    [[NgnEngine sharedInstance].configurationService setStringWithKey:NETWORK_TRANSPORT andValue:@"tcp"];
    //112.124.36.134  192.168.1.200
}

#pragma mark - Core Data stack

// Returns the managed object context for the application.
// If the context doesn't already exist, it is created and bound to the persistent store coordinator for the application.
- (NSManagedObjectContext *)managedObjectContext
{
    if (_managedObjectContext != nil) {
        return _managedObjectContext;
    }
    
    NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];
    if (coordinator != nil) {
        _managedObjectContext = [[NSManagedObjectContext alloc] init];
        [_managedObjectContext setPersistentStoreCoordinator:coordinator];
    }
    return _managedObjectContext;
}

// Returns the managed object model for the application.
// If the model doesn't already exist, it is created from the application's model.
- (NSManagedObjectModel *)managedObjectModel
{
    if (_managedObjectModel != nil) {
        return _managedObjectModel;
    }
    NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@"QianLi" withExtension:@"momd"];
    _managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];
    return _managedObjectModel;
}

// Returns the persistent store coordinator for the application.
// If the coordinator doesn't already exist, it is created and the application's store added to it.
- (NSPersistentStoreCoordinator *)persistentStoreCoordinator
{
    if (_persistentStoreCoordinator != nil) {
        return _persistentStoreCoordinator;
    }
    
    NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@"QianLi.sqlite"];
    
    NSError *error = nil;
    _persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];
    if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&error]) {
        /*
         Replace this implementation with code to handle the error appropriately.
         
         abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
         
         Typical reasons for an error here include:
         * The persistent store is not accessible;
         * The schema for the persistent store is incompatible with current managed object model.
         Check the error message to determine what the actual problem was.
         
         
         If the persistent store is not accessible, there is typically something wrong with the file path. Often, a file URL is pointing into the application's resources directory instead of a writeable directory.
         
         If you encounter schema incompatibility errors during development, you can reduce their frequency by:
         * Simply deleting the existing store:
         [[NSFileManager defaultManager] removeItemAtURL:storeURL error:nil]
         
         * Performing automatic lightweight migration by passing the following dictionary as the options parameter:
         @{NSMigratePersistentStoresAutomaticallyOption:@YES, NSInferMappingModelAutomaticallyOption:@YES}
         
         Lightweight migration will only work for a limited set of schema changes; consult "Core Data Model Versioning and Data Migration Programming Guide" for details.
         */
        NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
        //abort();
    }    
    
    return _persistentStoreCoordinator;
}

#pragma mark - Application's Documents directory

// Returns the URL to the application's Documents directory.
- (NSURL *)applicationDocumentsDirectory
{
    return [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject];
}

// Remote Notification Delegate
- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken
{
    NSLog(@"get token:%@",deviceToken);
    NSString *tokenJson = [NSString stringWithFormat:@"%@*%@",deviceToken,[UserDataAccessor getUserRemoteParty]];
    
    NSString *urlString= @"http://112.124.36.134:8080/notification/gettoken/";
    NSURL* url = [[NSURL alloc] initWithString:urlString];
    NSMutableURLRequest* request = [[NSMutableURLRequest alloc] initWithURL:url];
    
    NSString* requestDataLengthString = [[NSString alloc] initWithFormat:@"%d", [tokenJson length]];
    [request setHTTPMethod:@"POST"];
    [request setHTTPBody:[tokenJson dataUsingEncoding:NSUTF8StringEncoding]];
    [request setValue:@"application/json" forHTTPHeaderField:@"Content-Type"];
    [request setValue:requestDataLengthString forHTTPHeaderField:@"Content-Length"];
    [request setTimeoutInterval:30.0];
    
    [NSURLConnection
     sendAsynchronousRequest:request
     queue:[[NSOperationQueue alloc] init]
     completionHandler:^(NSURLResponse *response, NSData *data, NSError *error)
     {
         if ([data length] >0 && error == nil)
         {
             NSLog(@"Data:%@",[[NSString alloc] initWithData: data encoding: NSUTF8StringEncoding]);
         }
         else if ([data length] == 0 && error == nil)
         {
             NSLog(@"Nothing was downloaded.");
         }
         else if (error != nil)
         {
             NSLog(@"Error = %@", error.localizedDescription);
         }
     }];
}

- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error
{
    NSLog(@"Error in registration. Error: %@", error);
}

+ (QianLiAppDelegate *)sharedInstance
{
    return ((QianLiAppDelegate *)[[UIApplication sharedApplication] delegate]);
}

# pragma mark -- Push notification --
- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))handler
{
    if (application.applicationState == UIApplicationStateActive) {
        NSDictionary *aps = [userInfo objectForKey:@"aps"];
        NSDictionary *dic = [aps objectForKey:@"alert"];
        NSString *type = [dic objectForKey:@"loc-key"];
        if ([type isEqualToString:@"PUSHCALLING"]) {
            [[SipStackUtils sharedInstance] queryConfigurationAndRegister];
        }
    }
}

- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo
{
    // when app is runing in forground, this method is called. TODO:copy the above method to this method for ios6
    if (application.applicationState == UIApplicationStateActive) {
        NSDictionary *aps = [userInfo objectForKey:@"aps"];
        NSDictionary *dic = [aps objectForKey:@"alert"];
        NSString *type = [dic objectForKey:@"loc-key"];
        if ([type isEqualToString:@"PUSHCALLING"]) {
            [[SipStackUtils sharedInstance] queryConfigurationAndRegister];
        }
    }
}

#pragma mark -- UILocalNotification --
- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification
{
    //add code
}

-(void) onStackEvent:(NSNotification*)notification {
	NgnStackEventArgs * eargs = [notification object];
	switch (eargs.eventType) {
		case STACK_STATE_STARTING:
		{
			// this is the only place where we can be sure that the audio system is up
			[[SipStackUtils sharedInstance].soundService configureSpeakerEnabled:YES];
			break;
		}
		default:
			break;
	}
}

- (id)getAppDelegateAudioVC
{
    return _audioCallViewController;
}

<<<<<<< .mine
- (void)setTabItemBadge:(NSInteger)number
{
    UITabBarItem *histItem = [_tabController.tabBar.items objectAtIndex:0];
    if (number == 0) {
        histItem.badgeValue = nil;
    }
    else{
        histItem.badgeValue = [NSString stringWithFormat:@"%d", number];
    }
}

- (NSInteger)getTabItemBadge
{
    UITabBarItem *histItem = [_tabController.tabBar.items objectAtIndex:0];
    return  [histItem.badgeValue integerValue];
}

- (void)displayPushNotificationWarning
{
    if ([UIApplication sharedApplication].enabledRemoteNotificationTypes == UIRemoteNotificationTypeNone) {
        UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"提示" message:@"为了避免错过朋友打来的电话，请允许千里接受通知。允许的方法为在设置app->通知中心, 设置允许千里接受通知" delegate:nil cancelButtonTitle:@"知道了" otherButtonTitles:nil];
        [alertView show];
    }
}

=======
# pragma mark -- Umeng
- (void)umCheck:(NSNotification *)notification
{
    if (notification.userInfo) {
        NSArray *newReplies = [notification.userInfo objectForKey:@"newReplies"];
        int RepliesNumber = [newReplies count];
        // 在设置界面显示反馈的数目
        [_settingViewController newReplies:RepliesNumber];
    }
}

>>>>>>> .r1242
@end
